// Code generated by protoc-gen-go. DO NOT EDIT.
// source: common/collection.proto

/*
Package common is a generated protocol buffer package.

It is generated from these files:
	common/collection.proto
	common/common.proto
	common/configtx.proto
	common/configuration.proto
	common/ledger.proto
	common/policies.proto

It has these top-level messages:
	CollectionConfig
	StaticCollectionConfig
	CollectionPolicyConfig
	CollectionCriteria
	LastConfig
	Metadata
	MetadataSignature
	Header
	ChannelHeader
	SignatureHeader
	Payload
	Envelope
	Block
	BlockHeader
	BlockData
	BlockMetadata
	ConfigEnvelope
	ConfigGroupSchema
	ConfigValueSchema
	ConfigPolicySchema
	Config
	ConfigUpdateEnvelope
	ConfigUpdate
	ConfigGroup
	ConfigValue
	ConfigPolicy
	ConfigSignature
	HashingAlgorithm
	BlockDataHashingStructure
	OrdererAddresses
	Consortium
	Capabilities
	Capability
	BlockchainInfo
	Policy
	SignaturePolicyEnvelope
	SignaturePolicy
	ImplicitMetaPolicy
*/
package common

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// CollectionConfig defines the configuration of a collection object;
// it currently contains a single, static type.
// Dynamic collections are deferred.
type CollectionConfig struct {
	// Types that are valid to be assigned to Payload:
	//	*CollectionConfig_StaticCollectionConfig
	Payload isCollectionConfig_Payload `protobuf_oneof:"payload"`
}

func (m *CollectionConfig) Reset()                    { *m = CollectionConfig{} }
func (m *CollectionConfig) String() string            { return proto.CompactTextString(m) }
func (*CollectionConfig) ProtoMessage()               {}
func (*CollectionConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isCollectionConfig_Payload interface {
	isCollectionConfig_Payload()
}

type CollectionConfig_StaticCollectionConfig struct {
	StaticCollectionConfig *StaticCollectionConfig `protobuf:"bytes,1,opt,name=static_collection_config,json=staticCollectionConfig,oneof"`
}

func (*CollectionConfig_StaticCollectionConfig) isCollectionConfig_Payload() {}

func (m *CollectionConfig) GetPayload() isCollectionConfig_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CollectionConfig) GetStaticCollectionConfig() *StaticCollectionConfig {
	if x, ok := m.GetPayload().(*CollectionConfig_StaticCollectionConfig); ok {
		return x.StaticCollectionConfig
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CollectionConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CollectionConfig_OneofMarshaler, _CollectionConfig_OneofUnmarshaler, _CollectionConfig_OneofSizer, []interface{}{
		(*CollectionConfig_StaticCollectionConfig)(nil),
	}
}

func _CollectionConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CollectionConfig)
	// payload
	switch x := m.Payload.(type) {
	case *CollectionConfig_StaticCollectionConfig:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StaticCollectionConfig); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CollectionConfig.Payload has unexpected type %T", x)
	}
	return nil
}

func _CollectionConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CollectionConfig)
	switch tag {
	case 1: // payload.static_collection_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StaticCollectionConfig)
		err := b.DecodeMessage(msg)
		m.Payload = &CollectionConfig_StaticCollectionConfig{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CollectionConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CollectionConfig)
	// payload
	switch x := m.Payload.(type) {
	case *CollectionConfig_StaticCollectionConfig:
		s := proto.Size(x.StaticCollectionConfig)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StaticCollectionConfig constitutes the configuration parameters of a
// static collection object. Static collections are collections that are
// known at chaincode instantiation time, and that cannot be changed.
// Dynamic collections are deferred.
type StaticCollectionConfig struct {
	// the name of the collection inside the denoted chaincode
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// a reference to a policy residing / managed in the config block
	// to define which orgs have access to this collectionâ€™s private data
	MemberOrgsPolicy *CollectionPolicyConfig `protobuf:"bytes,2,opt,name=member_orgs_policy,json=memberOrgsPolicy" json:"member_orgs_policy,omitempty"`
	// the minimum number of internal/external peers required to be sent
	// private data to
	RequiredInternalPeerCount int32 `protobuf:"varint,3,opt,name=required_internal_peer_count,json=requiredInternalPeerCount" json:"required_internal_peer_count,omitempty"`
	RequiredExternalPeerCount int32 `protobuf:"varint,4,opt,name=required_external_peer_count,json=requiredExternalPeerCount" json:"required_external_peer_count,omitempty"`
}

func (m *StaticCollectionConfig) Reset()                    { *m = StaticCollectionConfig{} }
func (m *StaticCollectionConfig) String() string            { return proto.CompactTextString(m) }
func (*StaticCollectionConfig) ProtoMessage()               {}
func (*StaticCollectionConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *StaticCollectionConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *StaticCollectionConfig) GetMemberOrgsPolicy() *CollectionPolicyConfig {
	if m != nil {
		return m.MemberOrgsPolicy
	}
	return nil
}

func (m *StaticCollectionConfig) GetRequiredInternalPeerCount() int32 {
	if m != nil {
		return m.RequiredInternalPeerCount
	}
	return 0
}

func (m *StaticCollectionConfig) GetRequiredExternalPeerCount() int32 {
	if m != nil {
		return m.RequiredExternalPeerCount
	}
	return 0
}

// Collection policy configuration. Initially, the configuration can only
// contain a SignaturePolicy. In the future, the SignaturePolicy may be a
// more general Policy. Instead of containing the actual policy, the
// configuration may in the future contain a string reference to a policy.
type CollectionPolicyConfig struct {
	// Types that are valid to be assigned to Payload:
	//	*CollectionPolicyConfig_SignaturePolicy
	Payload isCollectionPolicyConfig_Payload `protobuf_oneof:"payload"`
}

func (m *CollectionPolicyConfig) Reset()                    { *m = CollectionPolicyConfig{} }
func (m *CollectionPolicyConfig) String() string            { return proto.CompactTextString(m) }
func (*CollectionPolicyConfig) ProtoMessage()               {}
func (*CollectionPolicyConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isCollectionPolicyConfig_Payload interface {
	isCollectionPolicyConfig_Payload()
}

type CollectionPolicyConfig_SignaturePolicy struct {
	SignaturePolicy *SignaturePolicyEnvelope `protobuf:"bytes,1,opt,name=signature_policy,json=signaturePolicy,oneof"`
}

func (*CollectionPolicyConfig_SignaturePolicy) isCollectionPolicyConfig_Payload() {}

func (m *CollectionPolicyConfig) GetPayload() isCollectionPolicyConfig_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CollectionPolicyConfig) GetSignaturePolicy() *SignaturePolicyEnvelope {
	if x, ok := m.GetPayload().(*CollectionPolicyConfig_SignaturePolicy); ok {
		return x.SignaturePolicy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CollectionPolicyConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CollectionPolicyConfig_OneofMarshaler, _CollectionPolicyConfig_OneofUnmarshaler, _CollectionPolicyConfig_OneofSizer, []interface{}{
		(*CollectionPolicyConfig_SignaturePolicy)(nil),
	}
}

func _CollectionPolicyConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CollectionPolicyConfig)
	// payload
	switch x := m.Payload.(type) {
	case *CollectionPolicyConfig_SignaturePolicy:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SignaturePolicy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CollectionPolicyConfig.Payload has unexpected type %T", x)
	}
	return nil
}

func _CollectionPolicyConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CollectionPolicyConfig)
	switch tag {
	case 1: // payload.signature_policy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SignaturePolicyEnvelope)
		err := b.DecodeMessage(msg)
		m.Payload = &CollectionPolicyConfig_SignaturePolicy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CollectionPolicyConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CollectionPolicyConfig)
	// payload
	switch x := m.Payload.(type) {
	case *CollectionPolicyConfig_SignaturePolicy:
		s := proto.Size(x.SignaturePolicy)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// CollectionCriteria defines an element of a private data that corresponds
// to a certain transaction and collection
type CollectionCriteria struct {
	Channel    string `protobuf:"bytes,1,opt,name=channel" json:"channel,omitempty"`
	TxId       string `protobuf:"bytes,2,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
	Collection string `protobuf:"bytes,3,opt,name=collection" json:"collection,omitempty"`
	Namespace  string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *CollectionCriteria) Reset()                    { *m = CollectionCriteria{} }
func (m *CollectionCriteria) String() string            { return proto.CompactTextString(m) }
func (*CollectionCriteria) ProtoMessage()               {}
func (*CollectionCriteria) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CollectionCriteria) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *CollectionCriteria) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *CollectionCriteria) GetCollection() string {
	if m != nil {
		return m.Collection
	}
	return ""
}

func (m *CollectionCriteria) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func init() {
	proto.RegisterType((*CollectionConfig)(nil), "common.CollectionConfig")
	proto.RegisterType((*StaticCollectionConfig)(nil), "common.StaticCollectionConfig")
	proto.RegisterType((*CollectionPolicyConfig)(nil), "common.CollectionPolicyConfig")
	proto.RegisterType((*CollectionCriteria)(nil), "common.CollectionCriteria")
}

func init() { proto.RegisterFile("common/collection.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 408 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x41, 0x6b, 0x1b, 0x31,
	0x10, 0x85, 0xb3, 0xad, 0x93, 0xb0, 0xd3, 0x43, 0x8d, 0x4a, 0xdd, 0x6d, 0x09, 0x69, 0x30, 0x3d,
	0x04, 0x0a, 0xbb, 0xd0, 0xfe, 0x80, 0x42, 0x4c, 0x20, 0x81, 0x40, 0x83, 0x72, 0xcb, 0x45, 0xc8,
	0xda, 0xc9, 0x5a, 0xa0, 0x95, 0x36, 0x23, 0xb9, 0xd8, 0xc7, 0xfe, 0xef, 0x1e, 0x8a, 0x25, 0x3b,
	0xf6, 0x3a, 0xbe, 0xed, 0xcc, 0x7b, 0xf3, 0xad, 0xe6, 0x49, 0xf0, 0x49, 0xb9, 0xb6, 0x75, 0xb6,
	0x52, 0xce, 0x18, 0x54, 0x41, 0x3b, 0x5b, 0x76, 0xe4, 0x82, 0x63, 0x27, 0x49, 0xf8, 0xf2, 0x71,
	0x6d, 0xe8, 0x9c, 0xd1, 0x4a, 0xa3, 0x4f, 0xf2, 0x78, 0x09, 0xc3, 0xc9, 0xcb, 0xc8, 0xc4, 0xd9,
	0x27, 0xdd, 0xb0, 0x47, 0x28, 0x7c, 0x90, 0x41, 0x2b, 0xb1, 0xa5, 0x09, 0x15, 0xb5, 0x22, 0xbb,
	0xc8, 0x2e, 0xdf, 0xfd, 0x38, 0x2f, 0x13, 0xad, 0x7c, 0x88, 0xbe, 0x7d, 0xc2, 0xcd, 0x11, 0x1f,
	0xf9, 0x83, 0xca, 0x55, 0x0e, 0xa7, 0x9d, 0x5c, 0x1a, 0x27, 0xeb, 0xf1, 0xbf, 0x0c, 0x46, 0x87,
	0xe7, 0x19, 0x83, 0x81, 0x95, 0x2d, 0xc6, 0xbf, 0xe5, 0x3c, 0x7e, 0xb3, 0x3b, 0x60, 0x2d, 0xb6,
	0x53, 0x24, 0xe1, 0xa8, 0xf1, 0x22, 0xee, 0xb1, 0x2c, 0xde, 0xf4, 0xcf, 0xb3, 0x25, 0xdd, 0x47,
	0x3d, 0xf1, 0xf8, 0x30, 0x4d, 0xfe, 0xa6, 0xc6, 0xa7, 0x3e, 0xfb, 0x05, 0x67, 0x84, 0xcf, 0x73,
	0x4d, 0x58, 0x0b, 0x6d, 0x03, 0x92, 0x95, 0x46, 0x74, 0x88, 0x24, 0x94, 0x9b, 0xdb, 0x50, 0xbc,
	0xbd, 0xc8, 0x2e, 0x8f, 0xf9, 0xe7, 0x8d, 0xe7, 0x76, 0x6d, 0xb9, 0x47, 0xa4, 0xc9, 0xca, 0xd0,
	0x03, 0xe0, 0xe2, 0x35, 0x60, 0xd0, 0x07, 0x5c, 0x2f, 0xf6, 0x00, 0xe3, 0x67, 0x18, 0x1d, 0x3e,
	0x2d, 0xbb, 0x83, 0xa1, 0xd7, 0x8d, 0x95, 0x61, 0x4e, 0xb8, 0xd9, 0x33, 0xe5, 0xfe, 0xf5, 0x25,
	0xf7, 0x8d, 0x9e, 0x06, 0xaf, 0xed, 0x1f, 0x34, 0xae, 0xc3, 0x9b, 0x23, 0xfe, 0xde, 0xf7, 0xa5,
	0xdd, 0xc4, 0xff, 0x66, 0xc0, 0x76, 0xb2, 0x26, 0x1d, 0x90, 0xb4, 0x64, 0x05, 0x9c, 0xaa, 0x99,
	0xb4, 0x16, 0xcd, 0x3a, 0xf0, 0x4d, 0xc9, 0x3e, 0xc0, 0x71, 0x58, 0x08, 0x5d, 0xc7, 0x98, 0x73,
	0x3e, 0x08, 0x8b, 0xdb, 0x9a, 0x9d, 0x03, 0x6c, 0xdf, 0x45, 0x0c, 0x2a, 0xe7, 0x3b, 0x1d, 0x76,
	0x06, 0xf9, 0xea, 0xc2, 0x7c, 0x27, 0x15, 0xc6, 0x18, 0x72, 0xbe, 0x6d, 0x5c, 0x3d, 0xc0, 0x37,
	0x47, 0x4d, 0x39, 0x5b, 0x76, 0x48, 0x06, 0xeb, 0x06, 0xa9, 0x7c, 0x92, 0x53, 0xd2, 0x2a, 0x3d,
	0x48, 0xbf, 0xde, 0xf0, 0xf1, 0x7b, 0xa3, 0xc3, 0x6c, 0x3e, 0x5d, 0x95, 0xd5, 0x8e, 0xb9, 0x4a,
	0xe6, 0x2a, 0x99, 0xab, 0x64, 0x9e, 0x9e, 0xc4, 0xf2, 0xe7, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xf5, 0x25, 0xa8, 0x8c, 0x06, 0x03, 0x00, 0x00,
}
